# buffer

### Level 1

TODO: write an explanation of your exploit here!

Here we are trying to get the getbuf function to not return to the test_exploit function as this results in the sabotage messages. We want to switch the lights off so that we can steal the rocks! In order to do this we need to get to the ligths_off function. When we call the getbuf function the return address for when the getbuf function has completed is some address in the test_exploit function. We need to change this to the address of the lightsoff function. In order to do so we are creating an exploit with 88 90s (as 90 is the symbol for nop which provides the necessary functionality to overwite the existing space created for the buffer and rbp)and then 5 00s and then the address of the lights off function in little endian order as the system requires this. The reason we have 88 90s is because of the way the stack and buffer are set up. The rbp register is 8 bytes and then we are creating a buffer from it of size 0x50 which is 80 giving a total of 88 bytes from the return address which itself is of size 8 bytes as can be seen from the q in the retq command. The 88 bytes of the buffer and rbp are written over with nops and then the return address is succesfully overwritten with the address of lights_off.

### Level 2

TODO: write an explanation of your exploit here!

Here we are trying to get the exploit to reach the sandwich function and help mr frizzle get the right number of sandwhiches. The way we reach the sandwhich function is very similar to the way we reached the lights_off function. We fill up the buffer with nop and the rbp with nop so that we can put the sandwhich function address in the return address. The sandwhich function however also needs arguments and for this we need to take into account the way we pass the arguments to the sandwhich function. So after we pass 88 nops 80 for the buffer and 8 for rbp, then we pass the address for the sandwhich function followed by 8 bytes fof the return of the sandwhich function followed by the argument for the sandwhich function. The reason we pass the 8 bytes for the return of the sandwhihc function is because of the fact that when a fucntion call is set up, first the arguments are passed in reverse order then the return address and then only thr function stack starts building up. The passing of the arguments for this function is also quite tricky as it is a structure. In our exploit we first write the cookie code and then only the elements of our size 4 int array that holds the number of sandwhiches of each kind. The reason for this is because we can see how the values are moved around in the machine code of the sandwhich function. There are a couple of lines that get the a value 20 units above the bottom of rbp into rdi to call find_total function. The 20 is got from 8 for rbp, 8 for return address and 4 for cookie. This means that array of 4 is only after cookie. Another way we can establish cookie is before array is from the fact that memory which is 16 above rbp (rbp 8 + return address 8) is moved into rax and then to another register and then is eventually moved into eax and is compared with the cookie literal. The fact that it is the cookie in GDB when printed, can be stored in a 4 byte register eax and is compared with the cookie literal imply that the cookie id comes before the array of 4 in the exploit. Also as a fun fact because the total number of sandwhiched has to be greater than 20 i have given all 4 elements of the array a value of 9!

### Level 3

TODO: write an explanation of your exploit here! 

The exploit for this problem is two fold. We need to return the getbuf function to the test_exploit function, but we also want to pass back our cookie value instead of 1 from getbuf back to test_exploit. We also want to be able to do this without affecting/corrupting the stack. We do this step by step. First we need to ensure that we fill the buffer up. To do this we first pass in our machine code in the hex format to the buffer. We do this via the disassemble and assemble tools. After that we fill up the rest of the buffer with 90s. We fill up with 90s till we reach the address of rbp. We fill up rbp with rbp's inital value itself as we are trying to go back to the test_exploit function. After rbp, we then put in the return address slot the address of the begining of the buffer where the machine code is kept as we want this to execute before we are actually returning to the test_exploit function. Once we get to this machine code, the following is sequentially executed. We move the cookie into rax, then we push the return address which is line 6 of the test_exploit function onto the stack and then conduct retq, which returns to the address. We have not corrupted the stack and we have returned the cookie value to test_exploit. We have successfully conducted this exploit.

### Level 4

TODO: write an explanation of your exploit here!

This exploit is rather similar to the previous exploit, the only difference being the fact that the stack is constantly changing with the rbp and rsp values getting randomized within a suitable range. In the getbufn function the buffer is of size not the same as the previous one but is of size 540 (544 in fact in memory). We need to put our machine code which does the same as the previous code (and a bit more in this buffer) and then alter getbufn return to the address of this code. We need to do this without corrupting the stack. To ensure this, we fill the buffer up with nops (90) forming a nop sled. This is done to ensure that despite not knowing the exact position of the rsp and rbp, we can calculate some memory value within this nop slope, as the max the rsp and rbp can vary by is 240 and so if we use this and add it to an average rbp value we see over several runs, so that when we return to this value it will always be in the nop sled (as the buffer itself is of size 540)  we can ensure that we always return to a point in the nop sled. Since the buffer is of 544 we fill it nops and then at the very end of those 544 bytes we put in the machine code so that the last byte of machine code is in the 544th byte. We then put random values in rbp and then in the return address put the return address. Now from the nop sled we reach the machine code. The machine code puts the cookie in rax, puts the old rbp value which changes from run to run in rbp as we dont want to change the buffer and then we push the return address on the stack which is the line after the func call to getbuf in test_exploit and then lastly we ret. All this ensures that over 5 runs the functionality that is required is met. 
